
- categories = Event.categories.map { |k, v| [translate(k, scope: %i[category title]), k] }
- languages = I18nData.languages(I18n.locale).map { |k,v| [v, k] }

= f.input :venue do
  .hint = @venue.name ? "#{@venue.name} - #{@venue.full_address}" : @venue.full_address

= f.input :name, placeholder: @event.category_name
= f.input :category, collection: categories
= f.input :description, as: :text, placeholder: @event.category_description
= f.input :room, hint: 'If the venue has more than one room, which room should seekers come to?'
= f.input :languages, collection: languages, input_html: { multiple: true, class: 'search' }, hint: 'Which language(s) can a seeker expect to be used at this event.'

.required.field
  = f.label :contact
  .hint Which yogi runs this program? This person will receive registration notifications, and be contacted automatically by the database to keep this event up to date.
  .two.fields
    = f.simple_fields_for :manager, f.object.manager do |ff|
      .field
        = ff.input_field :name, placeholder: (@event.manager.present? ? 'Name' : @event.venue.manager.name)
      .field
        = ff.input_field :email, placeholder: (@event.manager.present? ? 'Email' : @event.venue.manager.email)

.ui.divider

= f.input :recurrence, collection: Event.recurrences.map {|k, v| ["Every #{k.humanize}", k]}

.two.fields
  = f.input :start_date, as: :string, wrapper: :semantic_date, wrapper_html: { class: 'start' }
  = f.input :end_date, as: :string, wrapper: :semantic_date, wrapper_html: { class: 'end' }, input_html: { placeholder: 'Never' }

.two.fields
  = f.input :start_time, wrapper: :semantic_time, wrapper_html: { class: 'start' }, input_html: { autocomplete: 'off' }
  = f.input :end_time, wrapper: :semantic_time, wrapper_html: { class: 'end' }, input_html: { autocomplete: 'off', placeholder: 'Unspecified' }
